var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import React from "react";
import { Animated, Easing } from "react-native";
export var Bearing;
(function (Bearing) {
    Bearing[Bearing["Top"] = 0] = "Top";
    Bearing[Bearing["Bottom"] = 1] = "Bottom";
    Bearing[Bearing["Left"] = 2] = "Left";
    Bearing[Bearing["Right"] = 3] = "Right";
    Bearing[Bearing["Center"] = 4] = "Center";
})(Bearing || (Bearing = {}));
const FadeView = (_a) => {
    var { style, visible, children, duration = 200, fadeOutScale = 1.1, shouldEnterWithAnimation, bearingMoveDistance = 50, leaveBearing = Bearing.Center, entranceBearing = Bearing.Center, removeChildrenAfterDisapearance = false, animationFinished } = _a, rest = __rest(_a, ["style", "visible", "children", "duration", "fadeOutScale", "shouldEnterWithAnimation", "bearingMoveDistance", "leaveBearing", "entranceBearing", "removeChildrenAfterDisapearance", "animationFinished"]);
    const [visibleState, setVisibleState] = React.useState(shouldEnterWithAnimation === true ? !visible : visible);
    const [visibilityAnimValue] = React.useState(new Animated.Value(shouldEnterWithAnimation === true ? (visible ? 0 : 1) : visible ? 1 : 0));
    const theAnimation = React.useRef(null);
    const applyingVisibleState = React.useRef(shouldEnterWithAnimation === true ? !visible : visible);
    React.useEffect(() => {
        var _a;
        if (applyingVisibleState.current === visible) {
            return;
        }
        if (theAnimation && applyingVisibleState.current !== visible) {
            (_a = theAnimation.current) === null || _a === void 0 ? void 0 : _a.stop();
            theAnimation.current = null;
        }
        applyingVisibleState.current = visible;
        theAnimation.current = Animated.timing(visibilityAnimValue, {
            toValue: visible ? 1 : 0,
            duration,
            easing: Easing.inOut(Easing.linear),
            useNativeDriver: true,
        });
        if (visible && !visibleState) {
            setVisibleState(true);
        }
        theAnimation.current.start(({ finished }) => {
            theAnimation.current = null;
            if (finished) {
                setVisibleState(visible);
                animationFinished === null || animationFinished === void 0 ? void 0 : animationFinished(visible);
            }
        });
    }, [visible]);
    const transforms = [];
    if (entranceBearing !== Bearing.Center && visible === true) {
        if (entranceBearing === Bearing.Left || entranceBearing === Bearing.Right) {
            transforms.push({
                translateX: visibilityAnimValue.interpolate({
                    inputRange: [0, 1],
                    outputRange: [entranceBearing === Bearing.Left ? -bearingMoveDistance : bearingMoveDistance, 0],
                }),
            });
        }
        if (entranceBearing === Bearing.Top || entranceBearing === Bearing.Bottom) {
            transforms.push({
                translateY: visibilityAnimValue.interpolate({
                    inputRange: [0, 1],
                    outputRange: [entranceBearing === Bearing.Top ? -bearingMoveDistance : bearingMoveDistance, 0],
                }),
            });
        }
    }
    else if (visible === false && leaveBearing !== Bearing.Center) {
        if (leaveBearing === Bearing.Left || leaveBearing === Bearing.Right) {
            transforms.push({
                translateX: visibilityAnimValue.interpolate({
                    inputRange: [0, 1],
                    outputRange: [leaveBearing === Bearing.Left ? -bearingMoveDistance : bearingMoveDistance, 0],
                }),
            });
        }
        if (leaveBearing === Bearing.Top || leaveBearing === Bearing.Bottom) {
            transforms.push({
                translateY: visibilityAnimValue.interpolate({
                    inputRange: [0, 1],
                    outputRange: [leaveBearing === Bearing.Top ? -bearingMoveDistance : bearingMoveDistance, 0],
                }),
            });
        }
    }
    const containerStyle = {
        opacity: visibilityAnimValue,
        transform: [
            ...transforms,
            {
                scale: visibilityAnimValue.interpolate({
                    inputRange: [0, 1],
                    outputRange: [fadeOutScale, 1],
                }),
            },
        ],
    };
    return (React.createElement(Animated.View, Object.assign({ pointerEvents: visibleState ? "auto" : "none", style: [style, containerStyle] }, rest), removeChildrenAfterDisapearance ?
        visibleState && children
        : children));
};
export default FadeView;
